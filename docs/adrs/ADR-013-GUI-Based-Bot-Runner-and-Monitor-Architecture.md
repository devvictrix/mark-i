# ADR-013: GUI-Based Bot Runner and Monitor Architecture

- **Status:** Proposed
- **Date Decision Made:** 2025-08-30
- **Deciders:** DevLead

## Context and Problem Statement

Currently, Mark-I profiles are created and edited in the `MainAppWindow` GUI, but they are executed via the command line (`python -m mark_i run <profile>`). This creates a disjointed user experience, forcing users to switch between the editor and a terminal to test and run their automations. While the terminal provides detailed log output, it's not integrated into the user-friendly environment of the GUI.

To create a fully integrated and seamless user experience, we need to add the ability to **run and monitor profile-based automations directly from within the `MainAppWindow` GUI.**

This requires an architecture that can:
1.  Instantiate and run the `MainController` (the profile-based bot runner) in a background thread managed by the GUI's `AppController`.
2.  Provide clear UI controls to start and stop the bot for the currently loaded profile.
3.  Capture log output generated by the running bot.
4.  Redirect and display this log output in a dedicated panel within the main GUI in near real-time.

## Considered Options

1.  **Redirecting `sys.stdout`/`sys.stderr`:**
    - **Description:** Temporarily re-assign `sys.stdout` and `sys.stderr` to a custom file-like object (e.g., an `io.StringIO` or a custom class) that routes messages to a Tkinter widget.
    - **Pros:** Can capture almost all output, including from libraries that use `print()`.
    - **Cons:** It's a "blunt instrument" and can be tricky to manage, especially in a multi-threaded application. It's not thread-safe by default. Capturing structured log records is difficult; you only get the final formatted string. It can interfere with other parts of the application that might expect standard stdout/stderr.

2.  **Custom `logging.Handler` for GUI Updates (Chosen):**
    - **Description:** Create a custom subclass of `logging.Handler`. This handler's `emit()` method will be responsible for taking a `LogRecord` and safely passing its message to the GUI thread for display in a widget (e.g., a `CTkTextbox`). The `MainController`'s logging instance would be configured to use this handler when initiated from the GUI.
    - **Pros:**
        -   **Clean and Robust:** This is the standard, recommended way to integrate application logging with a custom destination.
        -   **Thread-Safe:** We can easily make the communication from the handler (in the bot thread) to the GUI (in the main thread) safe using a `queue.Queue` and the widget's `after()` method.
        -   **Structured Data:** The handler receives the full `LogRecord`, giving us access to the log level, module name, message, etc., allowing for future enhancements like color-coding logs by level.
        -   **Decoupled:** The bot's `MainController` doesn't need to know it's being run by a GUI; it just logs as usual. The integration is handled entirely at the logging configuration level.
    - **Cons:** Only captures output sent through Python's `logging` framework. Output from libraries using `print()` directly would not be caught (this is acceptable as our codebase exclusively uses `logging`).

3.  **Polling a Log File:**
    - **Description:** The `MainController` logs to a temporary file on disk. The GUI thread periodically opens, reads the new content from this file, and displays it.
    - **Pros:** Conceptually simple. Decouples the processes.
    - **Cons:** Inefficient due to constant disk I/O. Prone to display lag. File locking and management can be complex. The custom `logging.Handler` approach is far superior for in-process communication.

## Decision Outcome

**Chosen Option:** **Option 2: Custom `logging.Handler` for GUI Updates.**

**Justification:**

This approach is the most idiomatic, robust, and efficient solution for integrating a background process's logging with a Tkinter-based GUI. It provides a clean, thread-safe mechanism for communication without resorting to less stable methods like redirecting stdout or inefficient file polling. It preserves the structured nature of our logs, which opens the door for richer UI feedback in the future.

## High-Level Implementation Plan

1.  **Create `mark_i.ui.gui.logging_handler.py`:**
    -   Define a new class `GuiLoggingHandler(logging.Handler)`.
    -   It will be initialized with a thread-safe `queue.Queue`.
    -   Its `emit(record)` method will format the log record and `put()` the resulting string onto the queue.

2.  **Update `MainAppWindow` / `AppController`:**
    -   Add a new panel or tab for the "Bot Monitor," containing a `CTkTextbox` for log output and "Run Profile" / "Stop Profile" buttons.
    -   The `AppController` will manage the lifecycle of the `MainController`. When the "Run Profile" button is clicked:
        -   It will instantiate `GuiLoggingHandler` with a new queue.
        -   It will create and configure a new logger instance for the `MainController` session, adding the `GuiLoggingHandler` to it.
        -   It will instantiate `MainController`, passing the path of the currently loaded profile.
        -   It will call `main_controller.start()` to run the bot in its background thread.
        -   It will start a periodic `after()` job in the GUI to check the logging queue for new messages and append them to the `CTkTextbox`.

3.  **Update `MainController` (Minor Change):**
    -   The `MainController`'s `__init__` might be slightly adjusted to optionally accept a pre-configured logger instance, making the integration cleaner. If not provided, it will fall back to the standard logger.

## Consequences

-   A new UI component for monitoring will be added to `MainAppWindow`.
-   The `AppController` will gain new responsibilities for managing the `MainController`'s lifecycle and the logging bridge.
-   The user experience will be significantly improved by allowing profile execution and monitoring within a single, integrated interface.